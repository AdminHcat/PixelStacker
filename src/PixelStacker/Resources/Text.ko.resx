<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Action_Add_0" xml:space="preserve">
    <value>'{0}'추가</value>
  </data>
  <data name="Action_DisableQuantizer" xml:space="preserve">
    <value>Quantizer 비활성화</value>
  </data>
  <data name="Action_EnableQuantizer" xml:space="preserve">
    <value>Quantizer 활성화</value>
  </data>
  <data name="Action_Filter" xml:space="preserve">
    <value>필터</value>
  </data>
  <data name="Action_Remove_0" xml:space="preserve">
    <value>'{0}'제거</value>
  </data>
  <data name="Action_Save" xml:space="preserve">
    <value>저장</value>
  </data>
  <data name="AreYouSure" xml:space="preserve">
    <value>확실합니까?</value>
  </data>
  <data name="DDL_SelectProfile" xml:space="preserve">
    <value>프로필 선택</value>
  </data>
  <data name="Error_GlassRequiredForMultiLayer" xml:space="preserve">
    <value>다중 레이어를 요구하도록 선택하는 경우 하나 이상의 유리 재질을 활성화해야합니다.</value>
  </data>
  <data name="Error_NeedMoreRam" xml:space="preserve">
    <value>메모리가 부족합니다. 다시 시도하거나 문제가 계속되면 이미지 크기를 줄이십시오.</value>
  </data>
  <data name="Error_NonGlassRequired" xml:space="preserve">
    <value>유리가 아닌 재료를 하나 이상 선택해야합니다.</value>
  </data>
  <data name="Error_OneMaterialRequired" xml:space="preserve">
    <value>항상 하나 이상의 재료를 활성화해야합니다.</value>
  </data>
  <data name="Error_SomethingIsWrong" xml:space="preserve">
    <value>여기에 뭔가 잘못되었습니다.</value>
  </data>
  <data name="MaterialSelect_ColorProfile" xml:space="preserve">
    <value>색상 프로필</value>
  </data>
  <data name="MaterialSelect_IsMultiLayer" xml:space="preserve">
    <value>두 번째 레이어 활성화</value>
  </data>
  <data name="MaterialSelect_IsMultiLayerRequired" xml:space="preserve">
    <value>두 번째 레이어 필요</value>
  </data>
  <data name="MaterialSelect_IsSideView" xml:space="preserve">
    <value>측면보기</value>
  </data>
  <data name="MaterialSelect_Title" xml:space="preserve">
    <value>재료 선택</value>
  </data>
  <data name="OtherOptions_ConfirmFactoryReset" xml:space="preserve">
    <value>모든 PixelStacker 옵션을 다시 기본 설정으로 재설정 하시겠습니까? 재료, 크기,보기 상태, 렌더링 옵션 등이 포함됩니다.</value>
  </data>
  <data name="OtherOptions_Title" xml:space="preserve">
    <value>다른 옵션</value>
  </data>
  <data name="PreRenderOptions_Algorithm" xml:space="preserve">
    <value>연산</value>
  </data>
  <data name="PreRenderOptions_Algorithm_Tooltip" xml:space="preserve">
    <value>알고리즘마다 다른 전략을 사용하여
색상을 함께 결합합니다. 일부는 컬러 버킷을 사용하지만
다른 사람들은 주변 색상에 대한 위치 거리를 사용합니다. 시험
그들 모두를 선택하고 당신이 가장 좋아하는 것을 결정하십시오.</value>
  </data>
  <data name="PreRenderOptions_ColorCache" xml:space="preserve">
    <value>색상 캐시</value>
  </data>
  <data name="PreRenderOptions_ColorCacheSize" xml:space="preserve">
    <value>색상 캐시 크기</value>
  </data>
  <data name="PreRenderOptions_ColorCacheSize_Tooltip" xml:space="preserve">
    <value>값이 작을수록 빠르지 만 정확도는 떨어집니다.
값이 높을수록 느리지 만 더 정확합니다.</value>
  </data>
  <data name="PreRenderOptions_ColorCount" xml:space="preserve">
    <value>색상 수</value>
  </data>
  <data name="PreRenderOptions_ColorCount_Tooltip" xml:space="preserve">
    <value>최대 색상 수.</value>
  </data>
  <data name="PreRenderOptions_Dither" xml:space="preserve">
    <value>떨림</value>
  </data>
  <data name="PreRenderOptions_Dither_Tooltip" xml:space="preserve">
    <value>어떤 사람들은 디더링을 좋아합니다.
난 안해. 나는 결코하지 않는다. 나는 싫어
디더링. 하지만 헤이-당신은 당신을합니다.</value>
  </data>
  <data name="PreRenderOptions_Parallel" xml:space="preserve">
    <value>평행</value>
  </data>
  <data name="PreRenderOptions_Parallel_Tooltip" xml:space="preserve">
    <value>다음을 수행하여 양자화 프로세스 속도를 높입니다.
멀티 코어 CPU의 장점.

낮은 값 = 더 안정적
높은 값 = 더 빠름
매우 높은 값 = 가능한 글리치</value>
  </data>
  <data name="PreRenderOptions_QuantizerSettings" xml:space="preserve">
    <value>QuantizerSettings</value>
  </data>
  <data name="Progress_CompilingColorMap" xml:space="preserve">
    <value>컬러 맵 컴파일.</value>
  </data>
  <data name="Progress_Finished" xml:space="preserve">
    <value>끝마친.</value>
  </data>
  <data name="Progress_PreparingCanvasForTextures" xml:space="preserve">
    <value>페인팅을위한 캔버스 준비.</value>
  </data>
  <data name="Progress_QuantizingImage" xml:space="preserve">
    <value>이미지 양자화</value>
  </data>
</root>